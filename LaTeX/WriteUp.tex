\documentclass{article}

\title{Simulating and Reconstructing X-Ray CT Projections}
\author{Reece Garthwaite}
\date{}

\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{pythonhighlight}
\usepackage{float}
\usepackage{url}
\usepackage[english]{babel}
\usepackage{amsthm}
\usepackage{amsfonts}

\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]

\begin{document}
\maketitle

\begin{abstract}
I have chosen to simulate x-ray transmission through digital phantoms, using energy dependent attenuation from NIST data, to generate sinograms that I then reconstruct using back projection methods.
\end{abstract}

\section{Introduction}
Computed tomography (CT) scans are a form of medical imagery that uses x-rays to  create images of the body. CT scans reconstruct cross sectional images of the body from multiple projections of x-ray scans at a range of angles. This project aims to deepen my understanding of medical imaging techniques through the simulation and reconstruction of CT projections. 

This work particularly focuses on incorporating energy-dependent attenuation coefficients, derived from NIST data, to accurately model materials like bone and soft tissue, thereby allowing for the investigation of phenomena such as beam hardening.

\section{Methods}

\subsection{Background Physics}
\subsubsection{X-ray generation}
X-rays are produced when high kinetic energy electrons are accelerated towards a positive anode in a x-ray tube. Tungsten is a common choice for the anode (due to its high melting point and high atomic number). Electrons come close to nuclei of the target, causing a deceleration and change in direction, converting kinetic energy into a spectrum of electromagnetic radiation. Incident electrons can ionise the material, removing an electron from the anode. As the electron orbit vacancy gets filled by a orbital shell electron in a further out shell a photon is emitted. As orbital energies and their differences are unique in atoms, this leads to what we call "characteristic radiation".
\cite{Tafti}

\begin{figure}
  \includegraphics[width=\linewidth]{xray_tube.png}
  \caption{Schematic of a X-ray tube}
  \label{fig:X-ray tube}
\end{figure}

Figure \ref{fig:X-ray tube} \cite{Mason} shows a diagram of a x-ray tube . Which helps to visualise the origin of the x-ray spectrum as electrons are emitted via thermionic emission and then accelerated toward a positively charged anode, where their interactions with the target produce both bremsstrahlung and characteristic radiation.

\subsubsection{Attenuation of X-rays}
As x-rays pass through matter, they are attenuated according to the Beer-Lambert law: 
\begin{equation} \label{bl}
I(E) = I_0 \cdot e^{-\mu(E) x}
\end{equation}

Where:
\begin{itemize}
  \item I = transmitted intensity of radiation after passing through the material
  \item $I_0$ : Initial intensity
  \item $\mu$ : Linear attenuation coefficient
  \item $x$ : Thickness of material
\end{itemize}

I have included  $\mu$ to be energy dependent as this is what is observed in experiments, and allows us to look for an interesting phenomenon known as beam hardening. I calculate $\mu$ using:
\begin{equation} \label{linearatt}
\mu(E) = \left(\frac{\mu}{\rho}\right) \cdot \rho
\end{equation}
Where $\left(\frac{\mu}{\rho}\right)$ is the mass attenuation coefficient from NIST \cite{nistXRayMass}

\subsection{Investigating Beam Hardening}
Beam hardening occurs during x-ray attenuation as higher energy (hard) X-rays penetrate dense materials more effectively than the low energy (soft) X-rays. This has the effect of shifting the peak of the bremsstrahlung radiation towards higher energies. Beam hardening cannot occur for monochromatic X-rays, as the average energy will not change, so we can predict that the characteristic radiation will not harden.
I used spekpy, a dedicated x-ray spectrum simulation toolkit, and matplotlib to generate a typical spectra from a Tungsten x-ray tube and plot for energies upto 150 keV. I used a 2mm Aluminium filter to remove low energy, non-diagnostic x-rays. We can use spekpys built in filter function for this but will also write our own filtering code shortly.

\begin{figure}
	\includegraphics[width=\linewidth]{typicalxrayspectra.png}
	\caption{X-ray Spectrum from a x-ray tube with a Tungsten target}
  \label{fig:basespectra}
\end{figure}

In Figure \ref{fig:basespectra} we can see the sharp characteristic peaks that correspond to Tungsten. Writing code for filtering using NIST data and interpolation to fit the number of data points required., 

\begin{python}
import pandas as pd
from scipy.interpolate import interp1d

# Load csv
bone_data = pd.read_csv("bone.csv", names=["Energy_MeV", "Mu_Rho"], header=None)#

# Convert energy to KeV
bone_data["Energy_KeV"] = bone_data["Energy_MeV"] * 1000

# Average out duplicates by grouping
bone_data = bone_data.groupby("Energy_KeV", as_index=False).mean()

# Convert to linear attenuation (mu = mu/rho * rho)
bone_density = 1.85  # g/cm^3
bone_data["Mu"] = bone_data["Mu_Rho"] * bone_density  # [cm^-1]
mu = bone_data["Mu"].to_numpy()

# Create interpolation function for attenuation coefficients
mu_interp = interp1d(bone_data["Energy_KeV"], bone_data["Mu"], bounds_error=False, fill_value="extrapolate")

mu_at_spectrum_energies = mu_interp(energies)

thickness_cm = 0.5
I0 = s.get_spk()

I_filtered = I0 * np.exp(-mu_at_spectrum_energies * thickness_cm)
\end{python}

\begin{figure}[H]
	\includegraphics[width=\linewidth]{beamhardening.png}
	\caption{Comparing X-ray spectra before and after passing through 0.5cm of bone}
  \label{fig:beamhardening}
\end{figure}

Figure \ref{fig:beamhardening} shows beam hardening on the X-ray spectrum. The lower-energy (soft) x-rays are preferentially attenuated, resulting in a spectrum that is skewed toward higher energies. Lower-energy photons are absorbed more readily than high-energy ones. As a result, the transmitted spectrum becomes "hardened," with its average energy increasing. We also don't see any hardening for the monochromatic peaks, as expected. 

Beam hardening is significant in image reconstruction, as it may result in characteristic artefacts. CT beam hardening artefacts are known as: streaking artefacts, where dark bands appear between dense structures, and cupping artefacts, where the center of a homogeneous object appears less attenuating than the periphery \cite{Murphy_2016}.

\subsection{Phantoms and Sinograms}
\subsubsection{Generating Phantoms}
In medical scans, phantoms are used as stand-ins for human tissues to ensure that systems and methods are working correctly. One common such phantom is the Shepp-Logan phantom \cite{Shepp_Logan_1974}. The Shepp-Logan phantom is defined as 10 ellipses with parameters from the original paper \cite{Shepp_Logan_1974} and serves as a model of the human head.

\begin{figure}.
	\includegraphics[width=\linewidth]{shepplogan.png}
	\caption{Shepp-Logan head phantom image}
	\label{fig:shepplogan}
\end{figure}

Using Jan Hrach's python code \cite{phantom_py}, I can recreate the Shepp-Logan phantom with constant attenuation coefficients.

Another phantom I created was a simple circle of bone surrounded by a larger circle of soft tissue. This was an easy way to test using the energy dependent attenuation coefficients. The $circlemask$ function is use to define circular regions on the phantom, which can then be assigned with properties for different materials. Using a phantom with simplified geometry allowed for clearer observation of attenuation characteristics.

Python code:\\

\begin{python}
def circlemask(radii, centre_x, centre_y, width, height):
    x, y = np.ogrid[:width, :height]
    mask = (x-centre_x)**2 + (y-centre_y)**2 <= radii**2
    return mask
   
width, height = 180,180
s = sp.Spek(kvp=150,th=12)
energies = s.get_k()
# Load each material from a csv file
mu_bone = load_mu_data(r"code\bone.csv", density=1.85, energy_range_KeV=energies)
mu_tissue = load_mu_data(r"code\soft_tissue.csv", density=1.06, energy_range_KeV=energies)
E=len(energies)

phantom = np.zeros((height, width, E))
bone_mask = circlemask(10,width//2,height//2,width,height)
thigh_mask=circlemask(40,width//2,height//2,width,height)

# Background
phantom[:, :, :] = 0  # broadcast over all pixels

# Thigh region
phantom[thigh_mask, :] = mu_tissue

# Bone region
phantom[bone_mask, :] = mu_bone
\end{python}

Using matplotlib to display these phantoms:

\begin{figure}[H]
	\includegraphics[width=\linewidth]{simplephantom.png}
	\caption{Left: Shepp-Logan phantom. Right: Circular phantom with central bone inclusion ($\mu$ map at energy bin 50).}
	\label{fig:phantoms}
\end{figure}

\subsubsection{Sinograms}
A sinogram is a 2D representation of the projection data acquired in a CT scan, where each row corresponds to a 1D projection taken at a specific angle. Before we can reconstruct the cross-sectional image of the scanned object, the initial x-ray attenuation measurements are compiled into this sinogram format.

To understand image reconstruction, we need to define projections. A projection in CT scans represents the total attenuation of x-rays along a specific path of the object, mathematically this is represented as a line integral. At an angle $\theta$, the parallel beam geometry represents a new coordinate system $(r, s)$ in which the intensity profile $I_\theta (r)$ is measured. Other beam geometries such as fan or cone geometries require different methodology.

$$\begin{pmatrix} r \\ s \end{pmatrix} = R \begin{pmatrix} x \\ y \end{pmatrix} = \begin{pmatrix} \cos\theta & \sin\theta \\ -\sin\theta & \cos\theta \end{pmatrix} \begin{pmatrix} x \\ y \end{pmatrix}$$

Conversely,
$$\begin{pmatrix} x \\ y \end{pmatrix} = R^T \begin{pmatrix} r \\ s \end{pmatrix} = \begin{pmatrix} \cos\theta & -\sin\theta \\ \sin\theta & \cos\theta \end{pmatrix} \begin{pmatrix} r \\ s \end{pmatrix}$$

\begin{figure}[H]
	\includegraphics[scale=0.6]{coordinate_system.png}
	\caption{The object is defined in the Cartesian coordinate system $(x,y)$. For a projection at angle $\theta$, a new coordinate system $(r,s)$ is defined, where r is the perpendicular distance from the origin to the x-ray ray, and s is the coordinate along the ray path}
	\label{fig:coord}
\end{figure}

With parallel beams at a fixed angle $\theta$, the measured intensity at position $r$ along $L_{(r,\theta)}$ is given by the Beer-Lambert law:

\begin{align}
I_{\theta}(r) &= I_0 \cdot \exp\Bigl({-\int\limits_{L_{(r,\theta)}} \mu (x,y) ds} \Bigr) \\
& = I_0 \cdot \exp\Bigl({-\int\limits_{L_{(r,\theta)}} \mu \left(r \cos(\theta) - s \sin(\theta),r \sin(\theta) + s \cos(\theta)\right) ds} \Bigr) 
\end{align}

Each Intensity profile $I_\theta (r)$ is transformed into an attenuation profile $p_\theta (r)$, by taking the negative natural logarithm of the ratio of transmitted intensity to incident intensity:

\begin{align}
p_\theta (r) = - \ln \frac{I_\theta (r)}{I_0} = -\int\limits_{L_{(r,\theta)}} \mu \left(r \cos(\theta) - s \sin(\theta),r \sin(\theta) + s \cos(\theta)\right) ds
\end{align}

This attenuation profile is what our detector measures at each angle. Going back to the circle phantom example, we can write some code to simulate this:

\begin{python}
# Sum attenuation coefficients along the ray path (top to bottom) for each (width, energy).
# 'mu_total' is 2D (width, energy), representing total attenuation per ray per energy.
mu_total = phantom.sum(axis=0)

I = I0 * np.exp(-mu_total * pixel_thickness_cm)

# Sum transmitted intensities across all energies for each detector position.
# 'incident_intensity' is 1D (width,), representing the final polychromatic projection profile.
incident_intensity = I.sum(axis=1)

# Visualize detector readout (log form)
detector_readout= -np.log(incident_intensity + 1e-6)  # add epsilon to avoid log(0)
\end{python}

Plotting our result we get:
\begin{figure}[H]
	\includegraphics[scale=0.6]{detectorreadout.png}
	\caption{1D detector readout for our circular phantom, we see the increase in attenuation in the middle as we go through the bone.}
	\label{fig:detector1d}
\end{figure}

If we arrange projections from all angles (only $(0,\pi)$ as $(\pi, 2\pi)$ are redundant for parallel beams) side by side as a 2D image, we get a sinogram. We can view this 2D dataset $p(r, \theta)$ for our circular phantom in Figure \ref{fig:sinogramcircle}, this sinogram was generated using scipys ndimage.rotate to simulate the projections. 
Another, more interesting sinogram can be found from our more complex Shepp-Logan phantom, which we can see in Figure \ref{fig:sinogramshepp}. We can notice sinusoidal curves throughout the image, motivating the name sinogram.

\begin{figure}[H]
	\includegraphics[scale=0.5]{sinogramcircle.png}
	\caption{Sinogram for our circular phantom, note how it is constant in $\theta$ due to the rotational symmetry of the circle.}
	\label{fig:sinogramcircle}
\end{figure}

\begin{figure}[H]
	\includegraphics[scale=0.5]{sinogramshepp.png}
	\caption{Sinogram for the Shepp-Logan phantom.}
	\label{fig:sinogramshepp}
\end{figure}

The transformation of a function $\mu (x,y)$ into $p(r, \theta)$, is known as the Radon transform defined here as:
\begin{definition}
For a function $\mu(x,y)$ defined on $\mathbb{R}^2$, the Radon transform of $\mu$, denoted as $R\left\{\mu \right\}$, is defined as
\begin{align*}
p(r, \theta) &= R \left\{ \mu(x,y) \right\} \notag \\
             &= \int_{-\infty}^{\infty} \mu(r \cos\theta - s \sin\theta,\; r \sin\theta + s \cos\theta) \, ds
\end{align*}
\end{definition}
We can therefore phrase the problem of CT reconstruction as finding an inversion formula for the Radon transform \cite{Beatty2012}. 

\subsection{Inverse Radon Transform and Back Projection}
\subsubsection{Simple Back Projection}
One intuitive way we can think of image reconstruction is with 'Simple Back Projection'. If we take each projection $p_\theta (r)$ of our sinogram, and smear the value along lines perpendicular to the angle $\theta$ and add these up for all $\theta$ before normalising we should get back to our result. Imagine each projection as a shadow cast from a specific direction; by stacking up these shadows, we can approximate the object that cast them.
Mathematically, we define the back projection as:
\begin{definition}
Let $p = p(r, \theta)$. We define the back projection, $\mathcal{B} p$, at a point $(x,y)$ as
$$
\mathcal{B} p(x,y) = \frac{1}{\pi} \int_{0}^{\pi} p(x \cos(\theta) + y \sin(\theta), \theta) d\theta
$$
\end{definition}

In practice, we implement this by:
\begin{itemize}
	\item Taking each row of the sinogram (a projection)
	\item Replicating it across a 2D grid (smearing)
	\item Rotating it back in place
	\item Summing the results across all angles
\end{itemize}

Or in python code:

\begin{python}
# Initialize reconstruction
reconstruction = np.zeros((width, height))

# Backproject each angle's projection
for i, angle in enumerate(angles):
    # Expand the 1D projection into a 2D image by smearing along the angle
    projection = sinogram[i]
    expanded = np.tile(projection, (width, 1))  # Repeat along y-axis
    
    # Rotate back to original angle and accumulate
    rotated_back = ndimage.rotate(expanded, -angle, reshape=False, order=1)
    reconstruction += rotated_back

# Normalize
reconstruction /= len(angles)
\end{python}

\begin{figure}[H]
	\includegraphics[width=\linewidth]{sbpreconstructions.png}
	\caption{Simple Back Projection Reconstructions for our 2 phantoms.}
	\label{fig:SBPreconstructions}
\end{figure}

This roughly reconstructs the structure of the phantoms and we can make out some of the internal structure in both of our phantoms. Both of our phantoms are blurred and have pronounced dark corners. The dark corners are a known artefact, as they receive fewer ray contributions when we rotate around but to understand the blurring we need to requires further mathematical understanding.

Doing more quantitative analysis on how our Shepp-Logan reconstruction compares to the original we can compare Mean Square Error (MSE) and Structural Similarity Index Measure (SSIM) \cite{Sara_Akter_Uddin_2019}, for our Shepp-Logan:
\begin{itemize}
	\item MSE: 0.3778
	\item SSIM: 0.3130
\end{itemize}

In order to get these figures I ensured that both the original image and reconstruction was normalised, and applied a circle masking function to ensure we were only comparing the significant parts of the image and not the darkened corners.

MSE measures the average squared difference between actual and ideal pixel values. Since the normalized image ranges from 0 to 1, an MSE of 0.3778 is relatively high, indicating a low-fidelity reconstruction.

SSIM evaluates image quality by considering luminance, contrast and structural information. A value close to 1 would imply the 2 images are similar, so 0.3130 suggests significant degradation in these areas (which matches what we observe).

Overall quantitative image comparison is a tricky topic and both of these metrics have issues \cite{nilsson2020understandingssim}, but they still clearly indicate the need for a more sophisticated reconstruction algorithm.

\bibliography{References}
\bibliographystyle{ieeetr}
\end{document}
